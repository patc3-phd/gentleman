% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/cluster.R
\name{add_cluster_assignment}
\alias{add_cluster_assignment}
\title{Add cluster with iterative variable selection}
\usage{
add_cluster_assignment(
  df,
  v_cluster = NULL,
  k = NULL,
  maxit = 100,
  elimination = c("backward", "bidirectional"),
  max_vars_rm_or_add_each_it = Inf,
  return_df_cluster_instead = FALSE,
  new_var_name = "Cluster",
  weights = NULL
)
}
\arguments{
\item{df}{data.frame}

\item{v_cluster}{(character) vector of variable names to use in clustering (if \code{NULL}, use all)}

\item{k}{(numeric) number of clusters (if \code{NULL}, determined optimally; see \code{\link[=get_cluster]{get_cluster()}})}

\item{maxit}{(numeric) maximum number of iterations to select significant outcomes of clusters}

\item{elimination}{(character) whether to use backward or bidirectional elimination
(see Details; default \code{backward})}

\item{max_vars_rm_or_add_each_it}{(positive int) max number of variables to add and remove (each)
at each iteration (see Details; default \code{Inf})}

\item{return_df_cluster_instead}{(logical) whether to return \code{df} with only final clustering
variables and cluster assignment (default \code{FALSE})}

\item{new_var_name}{(character) new variable name}

\item{weights}{(numeric vector) variable weights for calculating Gower distances (default all 1)}
}
\value{
\code{df} with new cluster variable added
}
\description{
This function adds cluster assignment to each row of a data.frame with
iterative variable selection during clustering.
}
\details{
An initial set of clusters is determined using \code{\link[=get_cluster]{get_cluster()}} (Gower distance matrix with
clustering around medoids). Then, significant differences between clusters are determined using
\code{\link[=get_sig_differences_between_groups]{get_sig_differences_between_groups()}} (ANOVA for numeric variables, Chi-square for categorical
variables), and clustering is performed again using the set of significant variables (and the same \code{k}).
This variable-selection method is repeated until all remaining variables are significant,
or until \code{maxit} is reached. If \code{maxit} is reached before convergence, a warning is
thrown.

Variable selection can be achieved either through \strong{backward} elimination, where the full set
of candidate variables is first considered, then only significant predictors are kept in the
next iteration, and so on until all variables are significant. This guarantees that each iteration
will have a reduced set of variables.

Alternatively, variable selection can be achieved through \strong{bidirectional} elimination, where
at each step the full set of initial variables is tested for differences between clusters,
whether or not they were included in the previous iteration. All significant predictors are
included in the next iteration. This guarantees that the final set of variables will match
the output of \code{\link[=get_sig_differences_between_groups]{get_sig_differences_between_groups()}} with \code{test_vars=v_cluster} and \code{group=new_var_name}
(provided convergence has been reached).

If \code{max_vars_rm_or_add_each_it} is less than the number of variables to add or remove at a given
iteration, then this sets the number of changes made to the variable set for that iteration,
separately for variables removed and variables added (if elimination is bidirectional). For example,
if \code{max_vars_rm_or_add_each_it} is set to 1, then at each iteration, only one variable can be removed,
and only one variable can be added. If several candidates are available, then which variable(s)
get added or removed are selected randomly. This can be useful in determining cluster variable
importances using \code{calc_cluster_importances()}.

When \code{maxit} is set to 0, a warning is thrown indicating that no variable selection
is performed, and this is equivalent to using \code{\link[=get_cluster]{get_cluster()}} directly.
}
\examples{
\dontrun{
df <- df |> add_cluster_assignment()

df |>
   add_cluster_assignment(return_df_cluster_instead=TRUE) |>
   plot_density_by_groups(group="Cluster")
}

}
\seealso{
\code{\link[=get_cluster]{get_cluster()}}, \code{\link[=get_sig_differences_between_groups]{get_sig_differences_between_groups()}}, \code{\link[=calc_cluster_importances]{calc_cluster_importances()}}
}
\concept{cluster}
