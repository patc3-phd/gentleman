#### helper fn ####
# helper fn: format p values
#' Format p-values with 3 decimals, no leading 0s, and < .001
#'
#' This function formats a vector of p-values to match the common requirement of 3 decimals with
#' no leading zeros and indicated as "< .001" rather than .000.
#'
#' @param p A (named) numeric vector of p-values
#'
#' @return A (named) character vector of formatted p-values
#' @export
#'
#' @examples
#' format_p(c(0.000007, 0.15))
#'
#' @concept descriptives
format_p <- function(p)
{
  "
  input: (named) vector of p-values (numeric)
  output: (named) vector of formatted p-values (character)
  "

  p |>
    sprintf(fmt="%.3f") |> # keep 3 decimals
    sub(pattern = "^0.", replacement = "\\.") |> # remove leading 0
    replace_in_vector(find=".000", replace="< .001") |> # replace .000 with < .001
    replace_in_vector(find="NA", replace="") |>
    setNames(p |> names())
}

# helper fn: add group key to column names as suffix
#' Adds group key to table generated by some tbl_fn()
#'
#' This function adds the group key to a table generated by some \code{tbl_fn()}. This is
#' used by \code{get_desc_table()} when a grouping variable is specified.
#'
#' @param tbl Table generated by some tbl_fn()
#' @param group_key From \code{dplyr::group_map()}
#'
#' @return Table with group key added
#' @noRd
#'
#' @concept descriptives
add_group_key_to_desc_tbl <- function(tbl, group_key)
{
  "
  input: tbl from some tbl_fn; group_key from dplyr::group_map()
  return: tbl with column names changed to include group suffix (group name and key)
  "
  # add group key to column names
  cols <- colnames(tbl) != "Var"
  colnames(tbl)[cols] <- colnames(tbl)[cols] |>
    paste0(" (", names(group_key) |> paste0(collapse="."),
           " #", group_key[1,] |> unlist() |> paste0(collapse="."), ")")

  # out
  return(tbl)
}





#### numeric ####

# internal, generic function to get summary table for numeric vars from a df
#' Internal, generic function to get summary table for numeric variables
#'
#' This function is a generic \code{tbl_fn} function to use with numeric variables when calling
#' [get_desc_table()].
#'
#' This should be passed as \code{tbl_fn} when calling [get_desc_table()].
#' If you want to create a custom \code{tbl_fn}, you should model it after this one.
#'
#' @param df data.frame
#' @param vars Vector of variable names
#'
#' @return Table of descriptive statistics
#' @export
#'
#' @examples
#' \dontrun{
#' df |> tbl_fn_num("age")
#' }
#'
#' @seealso [gentleman::tbl_fn_fac()], [gentleman::get_desc_table()]
#'
#' @concept descriptives
tbl_fn_num <- function(df, vars)
{
  "
  use as tbl_fn in get_desc_table() for numeric vars
  return: df with columns Var, Mean (SD) for each `vars`
  "

  # helper fn
  format_mean_sd <- function(tbl)
  {
    tbl |>
      mutate(across(c(mean, sd), ~sprintf('%.2f',.) )) |>
      mutate(`Mean (SD)`=paste0(mean, " (", sd, ")") |>
               replace_in_vector("NaN (NA)", "")) |>
      select(-c(mean, sd))
  }

  # functions
  desc_fns <- list(
    `n`=~sum(!is.na(.)),
    `mean`=~mean(., na.rm=T),
    `sd`=~sd(., na.rm=T)
  )

  # summarize
  tbl <- df |>
    select(all_of(vars)) |>
    summarize(across(everything(), .fns=desc_fns, .names="{.col}---{.fn}")) |>
    pivot_longer(cols=everything(), names_to = c("Var", ".value"), names_sep="---") |>
    as.data.frame() |>
    format_mean_sd()

  # out
  return(tbl)
}


# get sig. test for difference between groups on numeric variables
#' Returns p-values from ANOVA for specified vars and grouping variable
#'
#' This function computes p-values using ANOVA for each variable in \code{vars} and grouping variable
#' specified in \code{group}
#'
#' @details
#' Post-hoc pairwise comparisons are obtained using [stats::pairwise.t.test()]. If no adjustment
#' for multiple comparisons is made and equal variances across groups are assumed (the default),
#' the tests correspond to Fisher's LSD. If equal variances are not assumed (by setting
#' `posthoc_equalvar` to `FALSE`), the tests correspond to Welch's t-tests.
#'
#' This function should be passed as `ana_fn` when calling [get_desc_table()] with a `group` argument
#' to obtain p-values. If you want to create a custom `ana_fn`, you should model it after this one.
#'
#' @param df data.frame
#' @param vars Vector of variable names
#' @param group Name of grouping variable
#' @param add_statistic (logical) Whether to add F-test to table
#' @param add_posthoc (logical) Whether to add post-hoc pairwise comparisons to table
#' @param posthoc_adjust Method for adjusting p-values (see [stats::p.adjust()]; default 'none')
#' @param posthoc_equalvar (logical) Whether to assume equal variances in all groups
#' (see Details; default `TRUE`)
#'
#' @return `data.frame` with columns `Var`, `p` (formatted p-values), `F-test` (if requested),
#' and (possibly adjusted) p-values from pairwise comparisons (if requested)
#' @export
#'
#' @examples
#' \dontrun{
#' df |> ana_fn_aov("age", "TreatmentGroup")
#' }
#'
#' @seealso [stats::aov()], [gentleman::get_desc_table()]
#'
#' @concept descriptives
ana_fn_aov <- function(df,
                       vars,
                       group,
                       add_statistic=FALSE,
                       add_posthoc=FALSE,
                       posthoc_adjust="none",
                       posthoc_equalvar=TRUE)
{
  # compute F test
  Flist <- vars |> lapply(
    \(v) tryCatch({
      f <- "`" |> paste0(v, "` ~ factor(`", group, "`)") |> as.formula()
      lm(f, df) |> summary() # to throw warning if data are constant: https://bugs.r-project.org/show_bug.cgi?id=18341
      aov(f, data=df) |> summary() |> (`[[`)(1)
    }, error=\(e) return(NA), warning=\(w) return(NA))
  ) |> setNames(vars)

  # p values
  ana <- Flist |>
    lapply(\(c)if(inherits(c,"anova")) c |>
             (\(s)s$`Pr(>F)`[1])() |>
             format_p() else NA) |>
    make_df_from_named_list(index="Var", value="p")

  # add F-test?
  if(add_statistic)
  {
    s <- Flist |>
      lapply(\(c)if(inherits(c,"anova")) c$`F value`[1] |>
               sprintf(fmt="%.2f") else NA) |>
      make_df_from_named_list(index="Var", value="F-test")
    ana <- ana |> left_join(s, by="Var")
  }


  # post-hoc?
  if(add_posthoc)
  {
    # get p-value pairs for each t-test
    p <- vars |> lapply(
      \(v) {
        .df<-df |> select(all_of(c(v,group))) |> na.omit()
        pairwise.t.test(x=.df[,v],
                        g=.df[,group],
                        p.adjust.method = posthoc_adjust,
                        pool.sd = posthoc_equalvar,
                        paired=FALSE)$p.value
      }
    ) |> setNames(vars)

    # add one pair at a time for one var at a time
    gs <- df[,group] |> unique()
    gs_pairs <- gs |> get_all_pairs()
    p_df<-data.frame(matrix(ncol=nrow(gs_pairs)+1, nrow=0))
    colnames(p_df) <- "Var" |> c("p"%p%gs_pairs[,1]%p%"-"%p%gs_pairs[,2])
    for(v in vars)
    {
      i <- nrow(p_df)+1
      rows<-dimnames(p[[v]])[[1]]
      cols<-dimnames(p[[v]])[[2]]
      for(c in cols)
      {
        for(r in rows)
        {
          .p<-p[[v]][r,c]
          if(!is.na(.p))
          {
            p_df[i,"Var"]<-v
            p_df[i,"p"%p%c%p%"-"%p%r]<-.p
          }
        }
      }
    }

    # format
    p_df <- p_df |> mutate(across(starts_with("p"),format_p))

    # add to ana
    ana <- ana |> left_join(p_df, by="Var")

  }


  # out
  return(ana)
}


# ana fn: RM ANOVA
#' Returns p-values from repeated-measures (RM) ANOVA for specified vars and grouping (time) variable
#'
#' This function computes p-values using RM-ANOVA for each variable in \code{vars} and grouping (time) variable
#' specified in \code{group}
#'
#' This should be passed as \code{ana_fn} when calling [get_desc_table()] with \code{group} and \code{id}
#' arguments to obtain p-values. Alternatively, this is the \code{ana_fn} used in wrapper
#' [get_desc_time()] when data.frame is not yet in long format.
#'
#' @param df data.frame (in long format)
#' @param vars Vector of variable names
#' @param group Name of grouping (time) variable
#' @param id ID var (unique identifier)
#' @param add_cohen (logical) Whether to add Cohen's d in addition to p-values
#'
#' @return \code{data.frame} with \code{Var} and \code{p} (formatted p-values) columns
#' @export
#'
#' @examples
#' df |>
#'    to_long(list(score=c("y1", "y2"))) |>
#'    ana_fn_rm_aov(vars="score", group="Time", id="id", add_cohen=TRUE)
#'
#' @seealso [gentleman::to_long()],
#' [gentleman::get_desc_table()],
#' [gentleman::get_desc_time()],
#' [stats::aov()]
#'
#' @concept descriptives
ana_fn_rm_aov <- function(df,
                          vars,
                          group,
                          id,
                          add_cohen=FALSE)
{
  "
  use as ana_fn in get_desc_table() for numeric vars
  df is in long format
  group is time variable
  return: named list of p-values (RM-ANOVA: vars ~ group)
  "

  ana <- vars |> lapply(
    \(v) tryCatch({
      aov("`" |> paste0(v, "` ~ factor(`", group, "`)") |> paste0("+ Error(factor(`", id, "`))") |> as.formula(), data=df) |>
        broom::tidy() |>
        filter(stratum=="Within", term==group) |>
        pull(p.value)
    }, error=\(e) return(NA))
  ) |> setNames(vars) |>
    make_df_from_named_list(index="Var", value="p")

  # effect size
  if(add_cohen)
  {
    # groups
    grps <- df[,group] |> unique()

    # get cohen
    get_cohen <- function(var)
    {
      df_wide <- df |>
        select(all_of(c(id, group, var))) |>
        pivot_wider(id_cols=all_of(id), names_from=all_of(group), values_from=all_of(var)) |>
        select(-all_of(id)) |>
        as.data.frame()
      diff <- df_wide[,2] - df_wide[,1]
      mean_diff <- mean(diff, na.rm=T)
      cohen <- mean_diff/sd(diff, na.rm=T)
      cohen <- cohen |> sprintf(fmt="%.2f") |> sub(pattern = "^(-?)0.", replacement = "\\1.") # weights::rd(2)
      mean_diff <- mean_diff |> sprintf(fmt="%.2f")
      c(Diff=mean_diff, Cohen=cohen)
    }

    cohen <- vars |>
      lapply(get_cohen) |>
      setNames(vars) |>
      make_df_from_named_list("Var", value=c("Diff", "Cohen"))

    # merge with p
    ana <- ana |> left_join(cohen, by="Var")

    # format diff with stars
    ana$Diff <- ana$Diff |> paste0(weights::starmaker(ana$p))
  }

  # format p
  ana <- ana |> mutate(p=p |> format_p())

  # out
  return(ana)
}


#### categorical ####

# internal, generic function to get summary table for categorical vars from a df
#' Internal, generic function to get summary table for factor variables
#'
#' This function is a generic \code{tbl_fn} function to use with factor variables when calling
#' [get_desc_table()].
#'
#' This should be passed as \code{tbl_fn} when calling [get_desc_table()]. If you want to create a custom
#' \code{tbl_fn}, you should model it after this one.
#'
#' @param df data.frame
#' @param vars Vector of variable names
#'
#' @return Table of descriptive statistics
#' @export
#'
#' @examples
#' \dontrun{
#' df |> tbl_fn_fac("Nationality")
#' }
#'
#' @seealso [gentleman::tbl_fn_num()], [gentleman::get_desc_table()]
#'
#' @concept descriptives
tbl_fn_fac <- function(df, vars)
{
  "
  use as tbl_fn in get_desc_table() for categorical vars
  return: df with columns Var, N, % for each category of `vars`
  "

  # helper fn
  get_desc_fac_n_or_prop <- function(df, vars, prop=FALSE)
  {
    # helper fn
    #get_table_for_column <- \(c) table(c, useNA="always")

    # do
    df |>
      select(all_of(vars)) |>
      {\(d) if(!prop) lapply(d, table, useNA="always")
        else lapply(d, \(c) (.t <- c |> table(useNA="no"))/sum(.t)) }() |>
      unlist() |>
      as.data.frame() |>
      {\(d)
        if(prop) d |> rename(`%`=1) |> mutate(`%`=sprintf("%.0f%%", `%`*100)) # format
        else d |> rename(N=1)}() |>
      tibble::rownames_to_column("Var")
  }

  # do
  tbl <- get_desc_fac_n_or_prop(df, vars) |>
    left_join(get_desc_fac_n_or_prop(df, vars, prop=T), by="Var")

  # add variable name before listing categories
  for (v in vars)
  {
    # alternative to dplyr::add_row():
    # https://stackoverflow.com/questions/11561856/add-new-row-to-dataframe-at-specific-row-index-not-appended
    i_row <- grep(v |> paste0("."), tbl$Var, fixed=T)[1] # .group is suffix added by table()
    tbl <- tbl |> add_row(Var=v, .before=i_row)
    tbl[i_row,] <- tbl[i_row,] |> unlist()# |> replace_in_vector(NA, "")
  }

  # replace NA with blank (for NA lines and rows with variable names)
  tbl[is.na(tbl)] <- ""

  # out
  return(tbl)
}



# get sig. test for difference between groups on factor (categorical) variables
#' Returns p-values from Chi-square tests for specified vars and grouping variable
#'
#' This function computes p-values using Chi-square tests
#' for each variable in \code{vars} and grouping variable specified in \code{group}
#'
#' This should be passed as \code{ana_fn} when calling [get_desc_table()] with a \code{group} argument
#' to obtain p-values. If you want to create a custom \code{ana_fn}, you should model it after this one.
#'
#' @param df data.frame
#' @param vars Vector of variable names
#' @param group Name of grouping variable
#' @param correct (logical) Whether to apply continuity correction (see [stats::chisq.test()])
#' @param simulate.p.value (logical) Whether to compute p-values by Monte Carlo simulation (see [stats::chisq.test()])
#' @param add_statistic (logical) Whether to add chi-square to table
#'
#' @return `data.frame` with columns `Var`, `p` (formatted p-values), and `Chi2` (if requested)
#' @export
#'
#' @examples
#' \dontrun{
#' df |> ana_fn_chisq("Nationality", "TreatmentGroup")
#' }
#'
#' @seealso [stats::chisq.test()]
#'
#' @concept descriptives
ana_fn_chisq <- function(df,
                         vars,
                         group,
                         correct=FALSE,
                         simulate.p.value=FALSE,
                         add_statistic=FALSE)
{
  # compute chi-square
  chisq <- vars |> lapply(
    \(v) tryCatch({
      chisq.test(x=df[,v] |> factor(),
                 y=df[,group] |> factor(),
                 correct=correct,
                 simulate.p.value=simulate.p.value)
    }, error=\(e) return(NA))
  )

  # get p-value
  ana <- chisq |>
    lapply(\(c)if(class(c)=="htest")c$p.value |> format_p() else NA) |>
    setNames(vars) |>
    make_df_from_named_list(index="Var", value="p")

  # add chi-square?
  if(add_statistic)
  {
    s <- chisq |>
      lapply(\(c)if(class(c)=="htest")c$statistic |> sprintf(fmt="%.2f") else NA) |>
      setNames(vars) |>
      make_df_from_named_list(index="Var", value="Chi2")
    ana <- ana |> left_join(s, by="Var")
  }

  # out
  return(ana)
}


#### table ####

# get a descriptive table for either num or fac vars
#' Get a table of descriptive statistics for numeric or factor variables
#'
#' This function returns a table of descriptive statistics generated by some \code{tbl_fn} function.
#' Additionally, statistics can be computed separately by groups. Groups can also be compared using
#' some \code{ana_fn} function.
#'
#' @details
#' For numeric variables, a natural choice is to use \code{tbl_fn=tbl_fn_num()}, while for
#' categorical variables, use \code{tbl_fn=tbl_fn_fac()}. Alternatively, custom functions can be specified.
#'
#' If \code{group} is specified, you have the option of requesting p-values (or some other statistic)
#' comparing groups. For numeric variables, a natural choice is \code{ana_fn=ana_fn_aov()}, which
#' computes p-values using analysis of variance. For factor variables, p-values can be obtained
#' with Chi-square tests using \code{ana_fn=ana_fn_chisq()}.
#'
#' @param df data.frame
#' @param vars Vector of variable names
#' @param tbl_fn Function that generates table
#' @param group Name of grouping variable
#' @param ana_fn Function that computes p-values (or other statistics to compare groups)
#' @param ... Additional named arguments passed to \code{ana_fn}
#'
#' @return Table of descriptive statistics
#' @export
#'
#' @examples
#' \dontrun{
#' # numeric variables
#' df |> get_desc_table(
#'     vars=c("age", "score"),
#'     tbl_fn=tbl_fn_num,
#'     group="TreatmentGroup",
#'     ana_fn=ana_fn_aov
#' )
#'
#' # factor variables
#' df |> get_desc_table(
#'     vars=c("Nationality", "Diagnostic"),
#'     tbl_fn=tbl_fn_fac,
#'     group="TreatmentGroup",
#'     ana_fn=ana_fn_chisq
#' )
#' }
#'
#' @seealso [gentleman::get_desc_time()],
#' [gentleman::tbl_fn_num()],
#' [gentleman::tbl_fn_fac()]
#' [gentleman::ana_fn_aov()],
#' [gentleman::ana_fn_chisq()]
#'
#' @concept descriptives
get_desc_table <- function(df,
                           vars,
                           tbl_fn,
                           group=NULL,
                           ana_fn=NULL,
                           ...)
{
  "
  input:
    df is dataframe
    vars is vector of variables
    tbl_fn is fn with (df, vars, group_key=NULL) arguments, returns df with column Var
    group is name of grouping variable in df
    ana_fn is fn with (df, vars, group) arguments, returns named list of values (match with Var)
    ... passed to ana_fn
  return: df in format returned by tbl_fn
  "

  #### global ####
  tbl <- df |> tbl_fn(vars)


  #### by group ####
  if(!is.null(group))
  {
    tbl_grp <- df |>
      group_by(across(all_of(group))) |>
      group_map(.f=~tbl_fn(.x,vars) |> add_group_key_to_desc_tbl(.y)) |>
      Reduce(f=\(df1,df2)full_join(df1,df2,by="Var"))

    # analysis values
    if(!is.null(ana_fn))
    {
      ana <- ana_fn(df, vars, group, ...)
      tbl_grp <- tbl_grp |> left_join(ana, by="Var")
    }

    # combine
    tbl <- tbl |>
      left_join(tbl_grp, by="Var") |>
      mutate(across(all_of(tbl_grp |> names()), ~replace_na(as.character(.x), "")))
  }


  #### out ####
  return(tbl)
}




# this is a wrapper, with group "Time" and id arg passed to ana_fn
# to long, then send var list to get_desc_table
# pass id=idvar to ana_fn via get_desc_table
# ana fn is aov with Error(id)
#' Get a table of descriptive statistics using RM-ANOVA for numeric variables
#'
#' This function returns a table of descriptive statistics for numeric variables
#' repeated over time (or otherwise repeated within subjects), with p-values calculated
#' through repeated-measures ANOVA. The data.frame is provided in wide format.
#'
#' @details
#' This function is a wrapper, pivoting a data.frame to long format with [to_long()]
#' before calling [get_desc_table()] with \code{tbl_fn=tbl_fn_num()}, \code{group="Time"},
#' \code{ana_fn=ana_fn_rm_aov()}, and \code{id="id"}. Currently there is no way to change
#' the analysis function.
#'
#' @param df data.frame
#' @param repeated_vars Named list of variables to be pivoted to long format
#' @param ... Additional named arguments passed to [ana_fn_rm_aov()]
#'
#' @return Table of descriptive statistics (output from [get_desc_table()])
#' @export
#'
#' @examples
#' v_repeated <- list(
#'    x=c("x1","x2","x3"),
#'    y=c("y1", "y2", "y3")
#'    )
#' df |> get_desc_time(v_repeated)
#'
#' @seealso [gentleman::get_desc_table()], [gentleman::to_long()], [gentleman::ana_fn_rm_aov()]
#'
#' @concept descriptives
get_desc_time <- function(df,
                          repeated_vars,
                          ...)
{
  # pivot
  dflong <- df |> to_long(repeated_vars)

  # do
  tbl <- get_desc_table(dflong,
                        vars=names(repeated_vars),
                        tbl_fn = tbl_fn_num,
                        group="Time",
                        ana_fn = ana_fn_rm_aov,
                        id="id",
                        ...)

  # out
  return(tbl)

}


#### homogeneous subsets ####
# get differences between subscales
#' Compares pairs of variables using matched-pairs t-tests
#'
#' This function compares pairs of variables using matched-pairs t-tests,
#' and also provides "homogeneous subsets" (similar to SPSS) following
#' a Bonferroni correction.
#'
#' p-values come from matched-pairs t-tests assuming equal variances
#' and are uncorrected for the number of tests. Subsets are generated following
#' a Bonferroni correction, and the rows and columns of the resulting matrix can
#' be ordered by variable mean: This is recommended to simplify examination
#' of the homogeneous subsets.
#'
#' @param df data.frame
#' @param vars Vector of variable names
#' @param order_output (logical) Whether to rank-order row and columns of subsets matrix by mean size (recommended)
#'
#' @return List with two matrices:
#' \describe{
#' \item{p_uncorrected}{Matrix of (unadjusted) p-values}
#' \item{subsets}{Matrix indicating whether each pair of variables are
#' part of the same subset (indicated by "SAMESET") or are instead significantly
#' different (blank entry) following a Bonferroni correction}
#' }
#' @export
#'
#' @examples
#' df |> compare_pairs_of_vars(c("x1", "x2", "x3"))
#'
#' @concept descriptives
compare_pairs_of_vars <- function(df,
                                  vars,
                                  order_output=TRUE)
{
  "
  input: df (filtered or not)
  output: tbl with homogeneous subsets given Bonferroni correction
  "

  v_BEACH <- vars
  df <- df |> select({{v_BEACH}})
  pairs <- do.call("expand.grid", list(c(0,1)) |> rep(length(v_BEACH)) |> list()) |>
    setNames(v_BEACH)
  pairs <- pairs[rowSums(pairs)==2,]

  # t tests
  ana <- list()
  p <- data.frame(matrix(1, nrow=length(v_BEACH), ncol=length(v_BEACH)))
  colnames(p) <- v_BEACH; rownames(p) <- v_BEACH
  for (i in 1:nrow(pairs))
  {
    v <- pairs[i,] |> as.logical() |> which() |> {\(ix)v_BEACH[ix]}()
    .p <- t.test(df[,v[1]], df[,v[2]], paired=TRUE, var.equal=TRUE, na.action=na.pass)$p.value
    p[v[1], v[2]] <- .p
    p[v[2], v[1]] <- .p
  }
  ana$p_uncorrected <- p

  # significant? as vector
  n_tests <- nrow(pairs)
  alpha <- (.05/n_tests)
  p[,] <- ifelse(p>alpha, "SAMESET", "")
  print("Bonferroni correction for" |> paste(n_tests, "tests"))

  # order p rows and columns by mean value
  if(order_output)
  {
    mean_order <- df |> colMeans(na.rm = T) |> order()
    p <- p[mean_order, mean_order]
  }
  ana$subsets <- p

  # out
  return(ana)

}


#### group differences ####
#' Get variables for which a group difference exists
#'
#' This function returns a vector of variable names for which
#' there is a significant difference between specified groups.
#'
#' @details
#' Group differences are tested using ANOVA (for numeric test variables) or
#' Chi-square (for categorical test variables) with [ana_fn_aov()] and [ana_fn_chisq()].
#' Significant differences are determined using the threshold \code{p < .05}.
#'
#' @param df data.frame
#' @param test_vars (character) vector of variable names to test for differences
#' (if \code{NULL}, all vars except \code{group})
#' @param group (character) name of grouping variable
#'
#' @return (character) vector of test variables for which there is a significant difference
#' between groups
#' @export
#'
#' @examples
#' \dontrun{
#' df |> get_sig_differences_between_groups(c("Age", "Nationality"), group="Gender")
#' }
#'
#' @concept descriptives
get_sig_differences_between_groups <- function(df, test_vars=NULL, group)
{
  # test vars
  if(is.null(test_vars)) test_vars <- (.n <- df |> names())[.n!=group]
  if(!all(c(test_vars, group) %in% names(df))) stop("Some variable(s) not in df")

  # reverse: pred ~ cluster
  v_cluster_num <- df |>
    select(all_of(test_vars)) |>
    select_if(~is.numeric(.x) & ((.x[!is.na(.x)]) |> unique() |> length())>2) |>
    names()
  v_cluster_fac <- test_vars |> setdiff(v_cluster_num)

  ana <- list()
  if(length(v_cluster_num)>0) ana$num <- ana_fn_aov(
    df=df,
    vars=v_cluster_num,
    group=group
  )

  if(length(v_cluster_fac)>0) ana$fac <- ana_fn_chisq(
    df=df,
    vars=v_cluster_fac,
    group=group
  )

  # which are sig
  sig <- ana |> lapply(\(l)l$p |>
                         substr_right(4) |>
                         as.numeric() |>
                         (`<`)(.05))
  if(sig |> lapply(is.na) |> unlist() |> any())
  {
    warning("Some p-values could not be calculated; assuming p > .05")
    sig <- sig |> lapply(replace_na, FALSE)
  }

  v_cluster <- v_cluster_num[sig$num] |> c(v_cluster_fac[sig$fac])

  # preserve original order
  v_cluster <- test_vars[v_cluster |> match(test_vars) |> sort()]

  # out
  v_cluster
}




#### plots ####


#' Plot density by groups
#'
#' This function plots densities using bar graphs for categorical variables and actual
#' densities for numeric variables, for several variables (panels) separately
#' by groups (optional; fill color). This is ideal for a combination of categorical,
#' ordinal, and numeric variables, but can also be used with a single type.
#'
#' @details
#' Non-numeric variables are always treated as such and get a bar graph. Numeric variables
#' can get either a bar graph (when the number of unique values excluding NA
#' is < \code{min_values_to_treat_as_numeric}), or a density plot.
#'
#' Density for categorical variables is calculated as \code{frequency/total} for each
#' distinct value, separately by groups.
#'
#' @param df data.frame
#' @param vars variables to plot (if \code{NULL}, all variables except \code{group})
#' @param group grouping variable (if \code{NULL}, all rows are assumed to belong to the same group)
#' @param fix_scales (logical) whether to keep same scales for all variables (default \code{FALSE})
#' @param min_values_to_treat_as_numeric (numeric) number of distinct values for a
#' numeric variable to be treated as continuous
#'
#' @return \code{ggplot2} plot
#' @export
#'
#' @examples
#' \dontrun{
#' df |> plot_density_by_groups()
#' df |> plot_density_by_groups(group="Gender")
#' }
#'
#' @concept descriptives
plot_density_by_groups <- function(df,
                                   vars=NULL,
                                   group=NULL,
                                   fix_scales=FALSE,
                                   min_values_to_treat_as_numeric=12)
{
  if(fix_scales) free_scales <- "fixed" else free_scales <- "free"
  if(is.null(group))
  {
    group <- "Full Sample"
    df[,group] <- "All"
  }

  #### select requested vars
  if(is.null(vars)) vars <- names(df)
  vars <- vars[vars!=group]


  #### numeric vars
  v_num <- df |>
    select(all_of(vars)) |>
    select(where(is.numeric)) |>
    sapply(\(c) c[!is.na(c)] |> unique() |> length() |> (`>=`)(min_values_to_treat_as_numeric))
  if(length(v_num)>0) v_num <- v_num |> which() |> names()


  #### one line per measure
  df_long <- df |>
    relocate(!!group, .after=last_col()) |>
    pivot_longer(
      cols=1:(ncol(df)-1), # not group
      names_to="Measure",
      values_to="Score", values_transform = list(Score = as.character)
    ) |>
    mutate(!!group:=factor(get(group)))


  #### density plot
  # example: https://stackoverflow.com/a/62393160/2303302
  # patterns: https://coolbutuseless.github.io/package/ggpattern/articles/developing-patterns-1.html
  .df <- df_long |> filter(Measure %in% vars)
  n_measures <- length(vars) - length(v_num)
  p <- ggplot(.df, aes(x=Score, fill=get(group))) + # fill must be factor; pattern=get(group)
    facet_wrap(~Measure, scales = free_scales) +
    geom_bar(data = subset(.df, !Measure %in% v_num),
             mapping = aes(y=after_stat(count/tapply(count,fill,sum)[fill])*n_measures),
             position = "identity",
             alpha =.5) +
    geom_density(data = subset(.df, Measure %in% v_num) |> mutate(across(Score, as.numeric)),
                 alpha = .5) +
    # geom_density_pattern(alpha=.5, lwd=1,
    #                      pattern_fill="black",
    #                      pattern_angle = 45,
    #                      pattern_density = 0.2,
    #                      pattern_spacing = 0.05,#0.025,
    #                      pattern_key_scale_factor = 0.6
    #                      ,pattern_size=1
    # ) +

    labs(y="Density", x="Score", fill=group) +
    #scale_pattern_manual(values=c("1"="none", "2"="stripe", "3"="circle")) +
    theme_bw(base_size = 16) #+
  #theme_minimal()


  # out
  p

}









