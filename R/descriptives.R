#### helper fn ####
# helper fn: format p values
#' Format p-values with 3 decimals, no leading 0s, and < .001
#'
#' This function formats a vector of p-values to match the common requirement of 3 decimals with
#' no leading zeros and indicated as "< .001" rather than .000.
#'
#' @param p A (named) numeric vector of p-values
#'
#' @return A (named) character vector of formatted p-values
#' @export
#'
#' @examples
#' format_p(c("0.000007", "0.15"))
format_p <- function(p)
{
  "
  input: (named) vector of p-values (numeric)
  output: (named) vector of formatted p-values (character)
  "

  p |>
    sprintf(fmt="%.3f") |> # keep 3 decimals
    sub(pattern = "^0.", replacement = "\\.") |> # remove leading 0
    replace_in_vector(find=".000", replace="< .001") |> # replace .000 with < .001
    replace_in_vector(find="NA", replace="") |>
    setNames(p |> names())
}

# helper fn: add group key to column names as suffix
#' Adds group key to table generated by some tbl_fn()
#'
#' This function adds the group key to a table generated by some \code{tbl_fn()}. This is
#' used by \code{get_desc_table()} when a grouping variable is specified.
#'
#' @param tbl Table generated by some tbl_fn()
#' @param group_key From \code{dplyr::group_map()}
#'
#' @return Table with group key added
add_group_key_to_desc_tbl <- function(tbl, group_key)
{
  "
  input: tbl from some tbl_fn; group_key from dplyr::group_map()
  return: tbl with column names changed to include group suffix (group name and key)
  "
  # add group key to column names
  cols <- colnames(tbl) != "Var"
  colnames(tbl)[cols] <- colnames(tbl)[cols] |>
    paste0(" (", names(group_key) |> paste0(collapse="."),
           " #", group_key[1,] |> unlist() |> paste0(collapse="."), ")")

  # out
  return(tbl)
}


# helper fn: pivot
#' Pivot data.frame from wide to long
#'
#' This function pivots a data.frame from wide to long.
#'
#' This is mostly a helper function. For more horsepower, see \code{tidyr::pivot_longer()}.
#'
#' @param df data.frame
#' @param repeated_vars Named list of variables to be pivoted to long format
#'
#' @return \code{df} in long format
#' @export
#'
#' @examples
#' v_repeated <- list(
#'    x=c("x1","x2","x3"),
#'    y=c("y1", "y2", "y3")
#'    )
#' df_long <- df |> to_long(v_repeated)
#'
#' @seealso [tidyr::pivot_longer()]
to_long <- function(df, repeated_vars)
{
  "
  input: repeated_vars is named list of var pairs
  output: dflong
  "
  # add id row
  df$id <- 1:nrow(df) |> factor()

  #
  dflong <- repeated_vars |> lapply(
    \(repeated_var)
    {
      # pivot
      dflong <- df["id" |> c(repeated_var)] |>
        pivot_longer(cols=all_of(repeated_var), names_to="Time") |>
        as.data.frame()
      for(t in 1:length(repeated_var)) dflong$Time <- dflong$Time |> replace_in_vector(find=repeated_var[t], replace=t)
      return(dflong)
    }
  )

  # col name
  for(i in 1:length(dflong)) colnames(dflong[[i]])[which(colnames(dflong[[i]])=="value")] <- names(repeated_vars)[i]

  # merge
  dflong <- dflong |> Reduce(f = \(df1, df2)merge(df1, df2, by=c("id", "Time"), sort=FALSE))

  # out
  return(dflong)
}



#### numeric ####

# internal, generic function to get summary table for numeric vars from a df
#' Internal, generic function to get summary table for numeric variables
#'
#' This function is a generic \code{tbl_fn} function to use with numeric variables when calling
#' \code{get_desc_table()}.
#'
#' This should be passed as \code{tbl_fn} when calling \code{get_desc}. If you want to create a custom
#' \code{tbl_fn}, you should model it after this one.
#'
#' @param df data.frame
#' @param vars Vector of variable names
#'
#' @return Table of descriptive statistics
#' @export
#'
#' @examples
#' df |> tbl_fn_num("age")
#'
#' @seealso [gentleman::tbl_fn_fac()] [gentleman::get_desc_table()]
tbl_fn_num <- function(df, vars)
{
  "
  use as tbl_fn in get_desc_table() for numeric vars
  return: df with columns Var, Mean (SD) for each `vars`
  "

  # helper fn
  format_mean_sd <- function(tbl)
  {
    tbl |>
      mutate(across(c(mean, sd), ~sprintf('%.2f',.) )) |>
      mutate(`Mean (SD)`=paste0(mean, " (", sd, ")") |>
               replace_in_vector("NaN (NA)", "")) |>
      select(-c(mean, sd))
  }

  # functions
  desc_fns <- list(
    `n`=~sum(!is.na(.)),
    `mean`=~mean(., na.rm=T),
    `sd`=~sd(., na.rm=T)
  )

  # summarize
  tbl <- df |>
    select(all_of(vars)) |>
    summarize(across(everything(), .fns=desc_fns, .names="{.col}---{.fn}")) |>
    pivot_longer(cols=everything(), names_to = c("Var", ".value"), names_sep="---") |>
    as.data.frame() |>
    format_mean_sd()

  # out
  return(tbl)
}
get_desc_num_summary_table <- tbl_fn_num # for backwards compatibility


# get sig. test for difference between groups on numeric variables
#' Returns p-values from ANOVA for specified vars and grouping variable
#'
#' This function computes p-values using ANOVA for each variable in \code{vars} and grouping variable
#' specified in \code{group}
#'
#' This should be passed as \code{ana_fn} when calling \code{get_desc} with a \code{group} argument
#' to obtain p-values. If you want to create a custom \code{ana_fn}, you should model it after this one.
#'
#' @param df data.frame
#' @param vars Vector of variable names
#' @param group Name of grouping variable
#'
#' @return \code{data.frame} with \code{Var} and \code{p} (formatted p-values) columns
#' @export
#'
#' @examples
#' df |> ana_fn_aov("age", "TreatmentGroup")
#'
#' @seealso [stats::aov()]
ana_fn_aov <- function(df, vars, group)
{
  "
  use as ana_fn in get_desc_table() for numeric vars
  return: named list of p-values (ANOVA: vars ~ group)
  "

  ana <- vars |> lapply(
    \(v) tryCatch({
      f <- "`" |> paste0(v, "` ~ `", group, "`") |> as.formula()
      lm(f, df) |> summary() # to throw warning if data are constant: https://bugs.r-project.org/show_bug.cgi?id=18341
      aov(f, data=df) |>
        summary() |>
        {\(s)s[[1]]$`Pr(>F)`[1]}() |>
        format_p()
    }, error=\(e) return(NA), warning=\(w) return(NA))
  ) |> setNames(vars) |>
    make_df_from_named_list(index="Var", value="p")

  # out
  return(ana)
}

# ana fn: RM ANOVA
#' Returns p-values from repeated-measures (RM) ANOVA for specified vars and grouping (time) variable
#'
#' This function computes p-values using RM-ANOVA for each variable in \code{vars} and grouping (time) variable
#' specified in \code{group}
#'
#' This should be passed as \code{ana_fn} when calling \code{get_desc} with \code{group} and \code{id}
#' arguments to obtain p-values. Alternatively, this is the \code{ana_fn} used in wrapper
#' \code{get_desc_time} when data.frame is not yet in long format.
#'
#' @param df data.frame (in long format)
#' @param vars Vector of variable names
#' @param group Name of grouping (time) variable
#' @param id ID var (unique identifier)
#' @param add_cohen (logical) Whether to add Cohen's d in addition to p-values
#'
#' @return \code{data.frame} with \code{Var} and \code{p} (formatted p-values) columns
#' @export
#'
#' @examples
#' df |>
#'    to_long(list(score=c("y1", "y2"))) |>
#'    ana_fn_aov(vars="score", group="Time", id="id", add_cohen=TRUE)
#'
#' @seealso [gentleman::to_long()] [gentleman::get_desc_time()] [stats::aov()]
ana_fn_rm_aov <- function(df, vars, group, id, add_cohen=FALSE)
{
  "
  use as ana_fn in get_desc_table() for numeric vars
  df is in long format
  group is time variable
  return: named list of p-values (RM-ANOVA: vars ~ group)
  "

  ana <- vars |> lapply(
    \(v) tryCatch({
      aov("`" |> paste0(v, "` ~ `", group, "`") |> paste0("+ Error(`", id, "`)") |> as.formula(), data=df) |>
        broom::tidy() |>
        filter(stratum=="Within", term==group) |>
        pull(p.value)
    }, error=\(e) return(NA))
  ) |> setNames(vars) |>
    make_df_from_named_list(index="Var", value="p")

  # effect size
  if(add_cohen)
  {
    # groups
    grps <- df[,group] |> unique()

    # get cohen
    get_cohen <- function(var)
    {
      df_wide <- df |>
        select(all_of(c(id, group, var))) |>
        pivot_wider(id_cols=all_of(id), names_from=all_of(group), values_from=all_of(var)) |>
        select(-all_of(id)) |>
        as.data.frame()
      diff <- df_wide[,2] - df_wide[,1]
      mean_diff <- mean(diff, na.rm=T)
      cohen <- mean_diff/sd(diff, na.rm=T)
      cohen <- cohen |> sprintf(fmt="%.2f") |> sub(pattern = "^(-?)0.", replacement = "\\1.") # weights::rd(2)
      mean_diff <- mean_diff |> sprintf(fmt="%.2f")
      c(Diff=mean_diff, Cohen=cohen)
    }

    cohen <- vars |>
      lapply(get_cohen) |>
      setNames(vars) |>
      make_df_from_named_list("Var", value=c("Diff", "Cohen"))

    # merge with p
    ana <- ana |> left_join(cohen, by="Var")

    # format diff with stars
    ana$Diff <- ana$Diff |> paste0(weights::starmaker(ana$p))
  }

  # format p
  ana <- ana |> mutate(p=p |> format_p())

  # out
  return(ana)
}


#### categorical ####

# internal, generic function to get summary table for categorical vars from a df
#' Internal, generic function to get summary table for factor variables
#'
#' This function is a generic \code{tbl_fn} function to use with factor variables when calling
#' \code{get_desc_table()}.
#'
#' This should be passed as \code{tbl_fn} when calling \code{get_desc}. If you want to create a custom
#' \code{tbl_fn}, you should model it after this one.
#'
#' @param df data.frame
#' @param vars Vector of variable names
#'
#' @return Table of descriptive statistics
#' @export
#'
#' @examples
#' df |> tbl_fn_fac("Nationality")
#'
#' @seealso [gentleman::tbl_fn_num()] [gentleman::get_desc_table()]
tbl_fn_fac <- function(df, vars)
{
  "
  use as tbl_fn in get_desc_table() for categorical vars
  return: df with columns Var, N, % for each category of `vars`
  "

  # helper fn
  get_desc_fac_n_or_prop <- function(df, vars, prop=FALSE)
  {
    # helper fn
    #get_table_for_column <- \(c) table(c, useNA="always")

    # do
    df |>
      select(all_of(vars)) |>
      {\(d) if(!prop) lapply(d, table, useNA="always")
        else lapply(d, \(c) (.t <- c |> table(useNA="no"))/sum(.t)) }() |>
      unlist() |>
      as.data.frame() |>
      {\(d)
        if(prop) d |> rename(`%`=1) |> mutate(`%`=sprintf("%.0f%%", `%`*100)) # format
        else d |> rename(N=1)}() |>
      tibble::rownames_to_column("Var")
  }

  # do
  tbl <- get_desc_fac_n_or_prop(df, vars) |>
    left_join(get_desc_fac_n_or_prop(df, vars, prop=T), by="Var")

  # add variable name before listing categories
  for (v in vars)
  {
    # alternative to dplyr::add_row():
    # https://stackoverflow.com/questions/11561856/add-new-row-to-dataframe-at-specific-row-index-not-appended
    i_row <- grep(v |> paste0("\\."), tbl$Var)[1] # .group is suffix added by table()
    tbl <- tbl |> add_row(Var=v, .before=i_row)
    tbl[i_row,] <- tbl[i_row,] |> unlist()# |> replace_in_vector(NA, "")
  }

  # replace NA with blank (for NA lines and rows with variable names)
  tbl[is.na(tbl)] <- ""

  # out
  return(tbl)
}
get_desc_fac_n_and_prop <- tbl_fn_fac # for backwards compatibility


# get sig. test for difference between groups on factor (categorical) variables
#' Returns p-values from Chi-square tests for specified vars and grouping variable
#'
#' This function computes p-values using Chi-square tests
#' for each variable in \code{vars} and grouping variable specified in \code{group}
#'
#' This should be passed as \code{ana_fn} when calling \code{get_desc} with a \code{group} argument
#' to obtain p-values. If you want to create a custom \code{ana_fn}, you should model it after this one.
#'
#' @param df data.frame
#' @param vars Vector of variable names
#' @param group Name of grouping variable
#' @param correct (logical) Whether to apply continuity correction (see [stats::chisq.test()])
#' @param simulate.p.value (logical) Whether to compute p-values by Monte Carlo simulation (see [stats::chisq.test()])
#'
#' @return \code{data.frame} with \code{Var} and \code{p} (formatted p-values) columns
#' @export
#'
#' @examples
#' df |> ana_fn_chisq("Nationality", "TreatmentGroup")
#'
#' @seealso [stats::chisq.test()]
ana_fn_chisq <- function(df, vars, group, correct=FALSE, simulate.p.value=FALSE)
{
  "
  use as ana_fn in get_desc_table() for categorical vars
  return: named list of p-values (Chi square: vars ~ group)
  "

  ana <- vars |> lapply(
    \(v) tryCatch({
      chisq.test(x=df[,v] |> factor(),
                 y=df[,group] |> factor(),
                 correct=correct,
                 simulate.p.value=simulate.p.value)$p.value |>
        format_p()
    }, error=\(e) return(NA))
  ) |> setNames(vars) |>
    make_df_from_named_list(index="Var", value="p")

  # out
  return(ana)
}


#### table ####

# get a descriptive table for either num or fac vars
#' Get a table of descriptive statistics for numeric of factor variables
#'
#' This function returns a table of descriptive statistics generated by some \code{tbl_fn} function.
#' Additionally, statistics can be computed separately by groups. Groups can also be compared using
#' some \code{ana_fn} function.
#'
#' @details
#' For numeric variables, a natural choice is to use \code{tbl_fn=tbl_fn_num}, while for
#' categorical variables, use \code{tbl_fn=tbl_fn_fac}. Alternatively, custom functions can be specified.
#'
#' If \code{group} is specified, you have the option of requesting p-values (or some other statistic)
#' comparing groups. For numeric variables, a natural choice is \code{ana_fn=ana_fn_aov}, which
#' computes p-values using analysis of variance. For factor variables, p-values can be obtained
#' with Chi-square tests using \code{ana_fn=ana_fn_chisq}.
#'
#' @param df data.frame
#' @param vars Vector of variable names
#' @param tbl_fn Function that generates table
#' @param group Name of grouping variable
#' @param ana_fn Function that computes p-values (or other statistics to compare groups)
#' @param ... Additional named arguments passed to \code{ana_fn}
#'
#' @return Table of descriptive statistics
#' @export
#'
#' @examples
#' df |> get_desc_table(
#'     vars=c("age", "score"),
#'     tbl_fn=tbl_fn_num,
#'     group="TreatmentGroup",
#'     ana_fn=ana_fn_aov
#' )
#'
#' df |> get_desc_table(
#'     vars=c("Nationality", "Diagnostic"),
#'     tbl_fn=tbl_fn_fac,
#'     group="TreatmentGroup",
#'     ana_fn=ana_fn_chisq
#' )
#'
#' @seealso [gentleman::get_desc_time()] [gentleman::tbl_fn_num()] [gentleman::tbl_fn_fac()]
#' [gentleman::ana_fn_aov()] [gentleman::ana_fn_chisq()]
get_desc_table <- function(df, vars, tbl_fn, group=NULL, ana_fn=NULL, ...)
{
  "
  input:
    df is dataframe
    vars is vector of variables
    tbl_fn is fn with (df, vars, group_key=NULL) arguments, returns df with column Var
    group is name of grouping variable in df
    ana_fn is fn with (df, vars, group) arguments, returns named list of values (match with Var)
    ... passed to ana_fn
  return: df in format returned by tbl_fn
  "

  #### global ####
  tbl <- df |> tbl_fn(vars)


  #### by group ####
  if(!is.null(group))
  {
    tbl_grp <- df |>
      group_by(across(all_of(group))) |>
      group_map(.f=~tbl_fn(.x,vars) |> add_group_key_to_desc_tbl(.y)) |>
      Reduce(f=\(df1,df2)full_join(df1,df2,by="Var"))

    # analysis values
    if(!is.null(ana_fn))
    {
      ana <- ana_fn(df, vars, group, ...)
      tbl_grp <- tbl_grp |> left_join(ana, by="Var")
    }

    # combine
    tbl <- tbl |>
      left_join(tbl_grp, by="Var") |>
      mutate(across(all_of(tbl_grp |> names()), ~replace_na(as.character(.x), "")))
  }


  #### out ####
  return(tbl)
}




# this is a wrapper, with group "Time" and id arg passed to ana_fn
# to long, then send var list to get_desc_table
# pass id=idvar to ana_fn via get_desc_table
# ana fn is aov with Error(id)
#' Computes descriptive statistics p-values using RM-ANOVA for numeric variables
#'
#' This function is a wrapper, pivoting a data.frame to long format
#' before calling \code{get_desc_table()} with \code{tbl_fn=tbl_fn_num}, \code{group="Time"},
#' \code{ana_fn=ana_fn_rm_aov}, and \code{id="id"}
#'
#' @param df data.frame
#' @param repeated_vars Named list of variables to be pivoted to long format
#' @param ... Additional named arguments passed to \code{ana_fn_rm_aov()}
#'
#' @return Table of descriptive statistics (output from \code{get_desc_table()})
#' @export
#'
#' @examples
#' v_repeated <- list(
#'    x=c("x1","x2","x3"),
#'    y=c("y1", "y2", "y3")
#'    )
#' df |> get_desc_time(v_repeated)
#'
#' @seealso [gentleman::get_desc_table()] [gentleman::to_long()] [gentleman::ana_fn_rm_aov()]
get_desc_time <- function(df, repeated_vars, ...)
{
  # pivot
  dflong <- df |> to_long(repeated_vars)

  # do
  tbl <- get_desc_table(dflong,
                        vars=names(repeated_vars),
                        tbl_fn = tbl_fn_num,
                        group="Time",
                        ana_fn = ana_fn_rm_aov,
                        id="id",
                        ...)

  # out
  return(tbl)

}


#### homogeneous subsets ####
# get differences between subscales
#' Compares pairs of variables using matched-pairs t-tests
#'
#' This function compares pairs of variables using matched-pairs t-tests,
#' and also provides "homogeneous subsets" (similar to SPSS) following
#' a Bonferroni correction.
#'
#' p-values come from matched-pairs t-tests assuming equal variances
#' and are uncorrected for the number of tests. Subsets are generated following
#' a Bonferroni correction, and the rows and columns of the resulting matrix can
#' be ordered by variable mean: This is recommended to simplify examination
#' of the homogeneous subsets.
#'
#' @param df data.frame
#' @param vars Vector of variable names
#' @param order_output (logical) Whether to rank-order row and columns of subsets matrix by mean size (recommended)
#'
#' @return List with two matrices:
#' \describe{
#' \item{\code{p_uncorrected}}{Matrix of (unadjusted) p-values}
#' \item{\code{subsets}}{Matrix indicating whether each pair of variables are
#' part of the same subset (indicated by "SAMESET") or are otherwise not significantly
#' different (blank entry) following a Bonferroni correction}
#' }
#' @export
#'
#' @examples
#' df |> compare_pair_of_vars(c("subscale1", "subscale2", "subscale3"))
compare_pairs_of_vars <- function(df, vars, order_output=TRUE)
{
  "
  input: df (filtered or not)
  output: tbl with homogeneous subsets given Bonferroni correction
  "

  v_BEACH <- vars
  df <- df |> select({{v_BEACH}})
  pairs <- do.call("expand.grid", list(c(0,1)) |> rep(length(v_BEACH)) |> list()) |>
    setNames(v_BEACH)
  pairs <- pairs[rowSums(pairs)==2,]

  # t tests
  ana <- list()
  p <- data.frame(matrix(1, nrow=length(v_BEACH), ncol=length(v_BEACH)))
  colnames(p) <- v_BEACH; rownames(p) <- v_BEACH
  for (i in 1:nrow(pairs))
  {
    v <- pairs[i,] |> as.logical() |> which() |> {\(ix)v_BEACH[ix]}()
    .p <- t.test(df[,v[1]], df[,v[2]], paired=TRUE, var.equal=TRUE, na.action=na.pass)$p.value
    p[v[1], v[2]] <- .p
    p[v[2], v[1]] <- .p
  }
  ana$p_uncorrected <- p

  # significant? as vector
  n_tests <- nrow(pairs)
  alpha <- (.05/n_tests)
  p[,] <- ifelse(p>alpha, "SAMESET", "")
  print("Bonferroni correction for" |> paste(n_tests, "tests"))

  # order p rows and columns by mean value
  if(order_output)
  {
    mean_order <- df |> colMeans(na.rm = T) |> order()
    p <- p[mean_order, mean_order]
  }
  ana$subsets <- p

  # out
  return(ana)

}

